/**
 * ============================================================================
 * 文件作用：解决方案列表 API 端点 (Solutions List API Endpoint)
 * ============================================================================
 *
 * 此文件是一个 Nitro 服务器 API 端点，用于获取所有解决方案的列表。
 *
 * 路由：GET /api/solutions
 *
 * 功能说明：
 * 1. 获取所有解决方案列表
 * 2. 按 order 字段排序（升序）
 * 3. 返回成功响应
 *
 * 返回值：
 * {
 *   success: true,              // 操作成功
 *   data: Solution[]             // 解决方案数组
 * }
 *
 * 工作流程：
 * 1. 从 mock 数据中获取所有解决方案
 * 2. 按 order 字段升序排序
 * 3. 返回排序后的解决方案列表
 *
 * Mock 数据说明：
 * - 当前使用 mock 数据（~/utils/mockData）
 * - 实际项目应该从 Supabase 数据库获取
 * - 可以通过替换 mockSolutions 为数据库查询来实现
 *
 * 排序规则：
 * - order 字段：数字类型，表示显示顺序
 * - 升序排序：从小到大（1, 2, 3...）
 * - 用途：控制解决方案在列表中的显示顺序
 *
 * 解决方案数据结构（Solution 类型）：
 * {
 *   id: string,                    // 解决方案 ID
 *   slug: string,                  // URL 标识符
 *   title: object | string,        // 标题（多语言或字符串）
 *   description: object | string,  // 描述（多语言或字符串）
 *   icon: string,                  // 图标名称
 *   category: string,              // 类别
 *   order: number,                 // 排序字段
 *   features: string[]            // 功能特性列表
 * }
 *
 * 性能优化：
 * - 内存排序：在内存中进行排序，无需数据库支持
 * - 可扩展：可以替换为数据库查询，提升性能
 *
 * 实际项目建议：
 * - 替换 mock 数据为 Supabase 数据库查询
 * - 添加分页支持（减少数据传输）
 * - 添加缓存机制（减少数据库查询）
 * - 添加筛选功能（按类别筛选）
 *
 * ============================================================================
 */

// ============================================================================
// 导入依赖项
// ============================================================================

// 导入 mock 数据
// ~/utils/mockData：mock 数据文件
// mockSolutions：解决方案的 mock 数据数组
import { mockSolutions } from '~/utils/mockData'

// ============================================================================
// Nitro 服务器 API 端点定义
// ============================================================================

// defineEventHandler：Nuxt 3/Nitro 提供的函数，用于定义服务器 API 端点
// - event：Nuxt 事件对象，包含请求信息
//
// 工作流程：
// 1. 获取所有解决方案（mockSolutions）
// 2. 按 order 字段升序排序
// 3. 返回成功响应
//
// 排序逻辑：
// - a.order - b.order：升序排序
// - 如果 a.order = 1, b.order = 2，结果为 -1，a 排在 b 前面
// - 如果 a.order = 2, b.order = 1，结果为 1，b 排在 a 前面
// - 如果 a.order = 1, b.order = 1，结果为 0，顺序不变
//
export default defineEventHandler((event) => {
  // ============================================================================
  // 获取并排序解决方案 (Get and Sort Solutions)
  // ============================================================================
  //
  // mockSolutions：解决方案的 mock 数据数组
  // .sort()：数组排序方法
  // (a, b) => a.order - b.order：排序函数
  //
  // 排序函数参数：
  // - a：第一个元素
  // - b：第二个元素
  //
  // 返回值：
  // - 负数：a 排在 b 前面（升序）
  // - 0：顺序不变
  // - 正数：b 排在 a 前面（升序）
  //
  // 示例说明：
  // - a.order = 1, b.order = 2：1 - 2 = -1（负数，a 排在 b 前面）
  // - a.order = 3, b.order = 1：3 - 1 = 2（正数，b 排在 a 前面）
  // - a.order = 2, b.order = 2：2 - 2 = 0（顺序不变）
  //
  // 为什么使用升序排序？
  // - order 字段表示显示顺序
  // - 较小的 order 值应该先显示
  // - 例如：order=1 应该排在 order=2 前面
  //
  // ============================================================================
  const sortedSolutions = mockSolutions.sort((a, b) => a.order - b.order)

  // ============================================================================
  // 返回成功响应 (Return Success Response)
  // ============================================================================
  //
  // 返回对象说明：
  // - success：表示操作是否成功（布尔值）
  // - data：包含排序后的解决方案数组
  //
  // 使用场景：
  // - 前端调用此 API 获取所有解决方案
  // - 解决方案列表页（/solutions）
  // - 解决方案筛选功能
  //
  // 返回格式：
  // {
  //   success: true,              // 操作成功
  //   data: Solution[]             // 解决方案数组
  // }
  //
  // ============================================================================
  return {
    success: true, // 操作成功
    data: sortedSolutions, // 排序后的解决方案数组
  }
})
